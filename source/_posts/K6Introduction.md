---
title: K6 Introduction
date: 2023-11-07 08:00:00
tags: [k6, test]
categories: 
    - 程式
---

# K6 Introduction

- 優點：
    1. **Integrable 可整合**：可整合至 CI / CD 流程內，以及測試結果可發送至像 Grafana 這類的外部儀表板系統內。
    2. **Scriptable 可制定腳本**：可以用腳本語言撰寫測試行為，才能夠更真實的模擬用戶行為。
    3. **Able to be a service 提供服務**：除了基礎的 CLI 程式外，最好還能有額外的測試服務，才能夠在未來日益加重的測試需求時，能夠用 load testing as a service 的模式做測試，而不用自行建立測試機台。
    4. **Well-documented 良好的文件**：圖文並茂而不冗長的文件，而不是只有 CLI 的說明頁或那冗長的 man page。
    5. **Actively maintained 有持續維護更新**：有更新才有可能支援較新的標準，例如 HTTP/2、HTTP/3、WebSocket、GraphQL、TLS 1.3 等。
    6. **Modern CLI design 現代化**：最好有 subcommand 把子功能分門別類，並且 subcommand / option / parameter / argument 的命名具有意義，不要是不知所謂的簡寫，像 Tar 這種老式工具沒有 subcommand 的概念，`tar --help` 一下就噴好幾頁的說明是不及格的。
    7. **No runtime 不需要 runtime**：不要有 runtime 或其它系統套件依賴，例如 JDK / JRE / .NET / Microsoft C++ Redistrubutable 這些 runtime 都只增加了配置環境時的複雜度，另一方面，用 Docker 容器方案當然也是增加配置複雜度的兇手之一。

- VUs：虛擬用戶數量
    
    在K6中，VUs（虛擬用戶）是一個重要的概念，用於模擬同時訪問您的應用程序的虛擬用戶數量。這些虛擬用戶實際上是K6測試腳本中定義的JavaScript代碼，它們模擬真實用戶對您的應用程序的行為。以下是有關VUs的一些解釋：
    
    1. 虛擬用戶數量（VUs）：VUs表示在測試過程中同時模擬的虛擬用戶數量。每個虛擬用戶都可以執行測試腳本中定義的操作，例如發送HTTP請求或執行其他操作。
    2. 并行性：VUs允許您模擬多個用戶同時訪問應用程序。通過增加VUs的數量，您可以增加測試的並行性，從而測試應用程序的性能和可擴展性。
    3. 延遲和並發：每個虛擬用戶之間可能存在隨機的延遲，以更好地模擬真實用戶的行為。這有助於確保測試更真實且更有意義。
    4. 定義VUs：在K6測試腳本中，您可以通過使用**`VU`**對象來定義虛擬用戶的行為。您可以指定虛擬用戶應執行的操作，以及其行為的規則。
    5. 監控和報告：K6允許您實時監控每個虛擬用戶的性能，並生成詳細的測試報告，以便評估應用程序的性能。
    
    總之，虛擬用戶數量（VUs）是K6中用來模擬並評估應用程序性能的重要概念。通過調整VUs的數量和定義虛擬用戶的行為，您可以進行不同類型的性能測試，並識別應用程序的性能瓶頸。
    
- Iteration Duration：迭代持續時間
    
    通常是性能測試報告中的一個重要指標之一。它表示在測試過程中，每個迭代或事務所花費的時間。這個指標有助於評估應用程序的性能和效能，特別是在多次重複操作或事務的情況下。
    
    解釋Iteration Duration的意思如下：
    
    1. 一個迭代通常代表測試中的一個操作或事務，例如向應用程序發送一個HTTP請求。
    2. Iteration Duration表示這個操作或事務的完成時間，通常以毫秒（ms）為單位。
    3. 迭代持續時間的平均值可以用來評估應用程序的響應時間。較短的平均迭代持續時間通常表示較好的性能。
    4. 通過追蹤迭代持續時間的變化，您可以檢測性能問題，例如在某些情況下迭代持續時間明顯增加，這可能表示性能瓶頸或延遲。
    5. 迭代持續時間也可用於評估應用程序的可擴展性。當您增加負載時，迭代持續時間是否保持在合理的範圍內，或者隨著負載的增加而急劇增長？
    
    總之，Iteration Duration是一個重要的性能測試指標，它幫助您了解應用程序的性能，識別性能問題，並評估其可擴展性。較短的迭代持續時間通常是理想的，但具體的閾值可能因應用程序的要求而有所不同。
    
- http_req_blocked：HTTP請求被阻止的次數
    
    在K6性能測試框架中，**`http_req_blocked`** 是一個性能測試指標，它表示HTTP請求被阻止的次數。這個指標的意義如下：
    
    1. HTTP請求阻止：**`http_req_blocked`** 計算了在測試過程中因各種原因而被阻止的HTTP請求的次數。這些原因可能包括網絡延遲、伺服器回應時間過長、TCP連接問題等。
    2. 阻塞次數：**`http_req_blocked`** 通常以整數值表示，該值代表在測試過程中發生的阻塞請求的次數。
    3. 性能問題檢測：當 **`http_req_blocked`** 值較高時，這可能表示您的應用程序在處理HTTP請求時遇到了性能問題或瓶頸。這些阻塞可能會導致用戶體驗不佳，因為用戶的請求無法得到及時處理。
    4. 診斷和優化：監控和記錄 **`http_req_blocked`** 可以幫助您識別應用程序的性能問題，並采取措施來優化它，例如改進伺服器的回應時間、增加伺服器容量或者緩解網絡延遲。
    
    總之，**`http_req_blocked`** 是K6中用於測試HTTP請求性能的一個指標，它有助於監視和評估應用程序的性能，特別是在處理大量並發請求的情況下。高 **`http_req_blocked`** 值可能需要進一步的調查和優化，以確保應用程序的穩定性和性能。
    
- http_req_connecting：HTTP請求建立連接的時間
    
    在K6性能測試框架中，**`http_req_connecting`** 是一個性能測試指標，它表示HTTP請求建立連接的時間。這個指標的意義如下：
    
    1. HTTP請求連接時間：**`http_req_connecting`** 指標記錄了在發出HTTP請求後，建立到目標伺服器的連接所花費的時間。這包括DNS解析、TCP連接建立和SSL/TLS握手等過程。
    2. 連接時間統計：**`http_req_connecting`** 通常提供了有關HTTP請求建立連接時間的統計信息，例如平均連接時間、最小連接時間、最大連接時間等。
    3. 性能分析：監控 **`http_req_connecting`** 指標有助於評估應用程序的性能，特別是在處理多個並發HTTP請求的情況下。較長的連接時間可能會影響用戶體驗，因為用戶的請求需要更長的時間才能建立連接，從而導致較長的等待時間。
    4. 優化建議：當 **`http_req_connecting`** 指標顯示連接時間過長時，您可能需要優化伺服器的設置、網絡配置或者使用較快的硬件資源，以減少連接時間，從而改善應用程序的性能。
    
    總之，**`http_req_connecting`** 是K6中用於監控和評估HTTP請求連接時間的一個指標，它有助於識別應用程序性能中的潛在瓶頸，並提供有關請求建立連接時間的信息，以便優化應用程序的性能。
    
- http_req_duration：HTTP請求的總持續時間
    
    在K6性能測試框架中，**`http_req_duration`** 是一個重要的性能測試指標，它表示一個HTTP請求的總持續時間。這個指標包括了從請求開始到收到回應完成的整個時間範圍。以下是對 **`http_req_duration`** 指標的解釋：
    
    1. HTTP請求持續時間：**`http_req_duration`** 記錄了每個HTTP請求的總時間，通常以毫秒（ms）為單位。這個時間包括了發送請求、等待回應、接收回應等所有與請求-回應週期相關的時間。
    2. 性能分析：監控 **`http_req_duration`** 指標有助於評估應用程序的性能，特別是在模擬多個並發用戶或客戶端對應用程序進行訪問時。較短的請求持續時間通常表示更快的回應時間，有助於提供更好的用戶體驗。
    3. 統計信息：**`http_req_duration`** 通常提供了一系列統計信息，如平均請求持續時間、最小請求持續時間、最大請求持續時間等。這些統計信息可以幫助您了解請求回應時間的分佈情況。
    4. 性能問題診斷：當 **`http_req_duration`** 值較長或波動較大時，這可能表明應用程序的性能存在問題。您可以使用這個指標來定位性能瓶頸、優化應用程序的回應時間、改進伺服器性能等。
    5. 優化建議：**`http_req_duration`** 可以指導性能優化工作。通過縮短請求持續時間，您可以提高應用程序的回應速度，減少用戶等待時間，從而改善用戶體驗。
    
    總之，**`http_req_duration`** 是K6中用於監測和評估HTTP請求性能的關鍵指標，它提供了有關請求-回應週期的時間信息，幫助您識別潛在的性能問題並進行性能優化。短而穩定的請求持續時間通常是良好性能的指標。
    
- http_req_receiving：接收HTTP請求回應的時間
    
    在K6性能測試框架中，**`http_req_receiving`** 是一個性能測試指標，它表示接收HTTP請求回應的時間。這個指標包括了從伺服器開始發送回應數據到客戶端接收完整回應的整個時間範圍。以下是對 **`http_req_receiving`** 指標的解釋：
    
    1. HTTP請求接收時間：**`http_req_receiving`** 記錄了每個HTTP請求的回應接收總時間，通常以毫秒（ms）為單位。這個時間包括了伺服器發送回應數據、客戶端接收回應數據以及可能的處理時間。
    2. 性能分析：監控 **`http_req_receiving`** 指標有助於評估應用程序的性能，特別是在模擬多個並發用戶或客戶端對應用程序進行訪問時。較短的回應接收時間通常表示更快的回應速度，有助於提供更好的用戶體驗。
    3. 統計信息：**`http_req_receiving`** 通常提供了一系列統計信息，如平均回應接收時間、最小回應接收時間、最大回應接收時間等。這些統計信息可以幫助您了解回應接收時間的分佈情況。
    4. 性能問題診斷：當 **`http_req_receiving`** 值較長或波動較大時，這可能表明應用程序的性能存在問題。您可以使用這個指標來定位性能瓶頸、優化應用程序的回應時間、改進伺服器性能等。
    5. 優化建議：**`http_req_receiving`** 可以指導性能優化工作。通過縮短回應接收時間，您可以提高應用程序的回應速度，減少用戶等待時間，從而改善用戶體驗。
    
    總之，**`http_req_receiving`** 是K6中用於監測和評估HTTP請求回應接收性能的關鍵指標，它提供了有關回應接收時間的信息，幫助您識別潛在的性能問題並進行性能優化。短而穩定的回應接收時間通常是良好性能的指標。
    
- http_req_sending：發送 HTTP 請求的時間
    
    在 K6 性能測試框架中，http_req_sending 是一個性能測試指標，表示發送 HTTP 請求的時間。這個指標用於衡量從測試腳本發出 HTTP 請求到請求完全發送給目標伺服器所花費的時間。以下是對 http_req_sending 指標的解釋：
    
    HTTP 請求發送時間：http_req_sending 記錄了每個 HTTP 請求的發送時間，通常以毫秒（ms）為單位。它代表了將請求數據從測試腳本發送到目標伺服器的時間。
    
    性能分析：監測 http_req_sending 指標有助於評估應用程序的性能，特別是在模擬多個並發用戶或客戶端對應用程序進行訪問時。這個指標可以幫助您了解請求發送的效率和速度，以及應用程序的性能如何。
    
    統計信息：http_req_sending 通常提供了一系列統計信息，如平均請求發送時間、最小請求發送時間、最大請求發送時間等。這些統計信息可以幫助您了解請求發送時間的分佈情況。
    
    性能問題診斷：當 http_req_sending 值較長或波動較大時，這可能表明在請求發送階段存在性能問題，可能需要優化請求發送的相關過程，以提高性能。
    
    總之，http_req_sending 是 K6 中用於監測和評估 HTTP 請求發送性能的重要指標，它提供了有關請求發送時間的信息，有助於識別應用程序性能中的潛在問題，並提供有關請求發送效率的洞察。短而穩定的請求發送時間通常是良好性能的指標。
    
- http_req_tls_handshaking：執行 TLS 握手的時間
    
    在 K6 性能測試框架中，**`http_req_tls_handshaking`** 是一個性能測試指標，表示執行 TLS 握手的時間。TLS（Transport Layer Security）是一種安全協議，用於加密和保護數據在客戶端和伺服器之間的傳輸。**`http_req_tls_handshaking`** 指標記錄了從發送 TLS 安全連接請求到建立 TLS 握手所花費的時間。以下是對 **`http_req_tls_handshaking`** 指標的解釋：
    
    1. TLS 握手時間：**`http_req_tls_handshaking`** 指標表示執行 TLS 握手的時間，通常以毫秒（ms）為單位。這包括了與伺服器建立安全連接所需的握手協議的執行時間。
    2. 安全通信：TLS 握手是為了確保數據在傳輸過程中的機密性和完整性。它通常包括客戶端向伺服器發送加密請求、伺服器回應並建立加密通道等步驟。
    3. 性能分析：監控 **`http_req_tls_handshaking`** 指標有助於評估應用程序的性能，特別是在模擬多個並發用戶或客戶端對應用程序進行訪問時。較長的 TLS 握手時間可能會導致請求的延遲，從而影響用戶體驗。
    4. 統計信息：**`http_req_tls_handshaking`** 通常提供一系列統計信息，如平均 TLS 握手時間、最小和最大 TLS 握手時間等，以便更好地了解 TLS 握手時間的分佈情況。
    5. 性能問題診斷：當 **`http_req_tls_handshaking`** 值較長時，可能需要優化 TLS 握手過程，以減少它對性能的潛在影響。
    
    總之，**`http_req_tls_handshaking`** 是 K6 中用於監測和評估執行 TLS 握手的性能的指標。TLS 握手時間的快慢會影響應用程序的性能和用戶體驗。較短而穩定的 TLS 握手時間通常是理想的。
    
- http_req_waiting：等待 HTTP 請求回應的時間
    
    在 K6 性能測試框架中，**`http_req_waiting`** 是一個性能測試指標，表示等待 HTTP 請求回應的時間。這個指標包括了從發送請求到接收伺服器回應之間的等待時間，即等待伺服器處理請求並返回回應的時間。以下是對 **`http_req_waiting`** 指標的解釋：
    
    1. HTTP 請求等待時間：**`http_req_waiting`** 指標記錄了每個 HTTP 請求的等待時間，通常以毫秒（ms）為單位。它代表了在發送請求後，等待伺服器處理請求並返回回應之間的時間。
    2. 性能分析：監控 **`http_req_waiting`** 指標有助於評估應用程序的性能，特別是在模擬多個並發用戶或客戶端對應用程序進行訪問時。較短的等待時間通常表示更快的回應速度，有助於提供更好的用戶體驗。
    3. 統計信息：**`http_req_waiting`** 通常提供了一系列統計信息，如平均等待時間、最小等待時間、最大等待時間等。這些統計信息可以幫助您了解等待時間的分佈情況。
    4. 性能問題診斷：當 **`http_req_waiting`** 值較長或波動較大時，這可能表明應用程序的性能存在問題，可能需要優化伺服器的處理能力、減少請求排隊時間等來改進性能。
    
    總之，**`http_req_waiting`** 是 K6 中用於監測和評估等待 HTTP 請求回應時間的關鍵指標，它提供了關於等待伺服器處理請求的時間的信息，有助於識別潛在的性能問題並進行性能優化。較短而穩定的等待時間通常有助於提供更好的用戶體驗。
    
- 統計指標：
    - `avg`：平均值
        
        這個指標表示所有樣本數據的平均值。在性能測試中，通常用來表示請求的平均響應時間。較低的平均響應時間通常表示更好的性能。
        
    - `max`：最大值
        
        此指標表示樣本數據中的最大值。在性能測試中，它代表了請求的最長響應時間。這個指標用於識別性能測試中的最壞情況。
        
    - `med`：中位數
        
        中位數是樣本數據排序后位於中間位置的值。在性能測試中，它代表中間響應時間，用於了解響應時間的分佈情況。
        
    - `min`：最小值
        
        此指標表示樣本數據中的最小值。在性能測試中，通常用來表示請求的最短響應時間。較低的最小響應時間通常表示更好的性能。
        
    - `p90`：百分位数90
        
        表示在數據中有90%的樣本值小於或等於這個值。通常在性能測試中，它用於捕捉較長響應時間的一部分情況，以更好地了解性能的穩定性。
        
    - `p95`：百分位数95
        
        表示在數據中有95%的樣本值小於或等於這個值。與 `p90` 類似，它用於捕捉較長響應時間的一部分情況。
        
    - `p99`：百分位数99
        
        表示在數據中有99%的樣本值小於或等於這個值。通常用於捕捉極端情況下的響應時間，以更好地了解性能的可靠性。


> 滿滿的AI感XD。這一篇是當初想在公司導入K6，用來取代VisualStudio的Web效能和負載測試。所以寫了一個Demo範例，再搭配上這篇AI文簡單說明各個指標的意思。最後總算是順利導入了，擺脫VisualStudio2019就是爽！